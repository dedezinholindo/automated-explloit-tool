"""
Comprehensive vulnerability scanning module using Nuclei and other tools
"""

import asyncio
import logging
import json
import subprocess
from typing import Dict, List, Any, Set
from pathlib import Path
import httpx

from ..core.config import platform_config, config
from ..core.scanner import ScanEngine

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Comprehensive vulnerability scanner"""
    
    def __init__(self, scan_engine: ScanEngine = None):
        self.scan_engine = scan_engine or ScanEngine()
        self.findings: List[Dict[str, Any]] = []
        
    async def scan_vulnerabilities(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive vulnerability scanning"""
        
        logger.info(f"Starting comprehensive vulnerability scan for: {target}")
        
        results = {
            'target': target,
            'scan_methods': {},
            'findings': [],
            'summary': {
                'total_findings': 0,
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            },
            'scan_duration': 0
        }
        
        start_time = asyncio.get_event_loop().time()
        
        # Multiple vulnerability scanning approaches
        scan_tasks = []
        
        # Nuclei scanner (primary)
        if platform_config.is_tool_enabled('nuclei'):
            scan_tasks.append(self._nuclei_scan(target, options))
        
        # SQL injection testing
        if platform_config.is_tool_enabled('sqlmap') and options.get('test_sqli', True):
            scan_tasks.append(self._sqlmap_scan(target, options))
        
        # Custom vulnerability checks
        scan_tasks.append(self._custom_vulnerability_checks(target, options))
        
        # Security headers analysis
        scan_tasks.append(self._security_headers_analysis(target, options))
        
        # SSL/TLS analysis
        if platform_config.is_tool_enabled('sslscan'):
            scan_tasks.append(self._ssl_analysis(target, options))
        
        # Execute scanning tasks
        scan_results = await asyncio.gather(*scan_tasks, return_exceptions=True)
        
        # Process results
        all_findings = []
        
        for i, result in enumerate(scan_results):
            method_name = f"scan_method_{i}"
            
            if isinstance(result, Exception):
                logger.error(f"Scan method {method_name} failed: {result}")
                results['scan_methods'][method_name] = {
                    'status': 'failed',
                    'error': str(result),
                    'findings': []
                }
            else:
                results['scan_methods'][method_name] = result
                
                # Collect findings
                if 'findings' in result:
                    all_findings.extend(result['findings'])
        
        # Deduplicate and categorize findings
        unique_findings = self._deduplicate_findings(all_findings)
        results['findings'] = unique_findings
        
        # Calculate summary
        summary = self._calculate_summary(unique_findings)
        results['summary'] = summary
        
        end_time = asyncio.get_event_loop().time()
        results['scan_duration'] = end_time - start_time
        
        logger.info(f"Vulnerability scan completed: {summary['total_findings']} findings ({summary['critical']} critical, {summary['high']} high)")
        
        return results
    
    async def basic_scan(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Basic vulnerability scan with essential checks"""
        
        logger.info(f"Starting basic vulnerability scan for: {target}")
        
        # Quick essential checks
        basic_tasks = [
            self._nuclei_basic_scan(target, options),
            self._security_headers_analysis(target, options),
            self._common_vulnerability_checks(target, options)
        ]
        
        scan_results = await asyncio.gather(*basic_tasks, return_exceptions=True)
        
        all_findings = []
        for result in scan_results:
            if not isinstance(result, Exception) and 'findings' in result:
                all_findings.extend(result['findings'])
        
        unique_findings = self._deduplicate_findings(all_findings)
        summary = self._calculate_summary(unique_findings)
        
        return {
            'target': target,
            'scan_type': 'basic',
            'findings': unique_findings,
            'summary': summary
        }
    
    async def exploitation_scan(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Exploitation-focused scanning"""
        
        logger.info(f"Starting exploitation scan for: {target}")
        
        results = {
            'target': target,
            'scan_type': 'exploitation',
            'exploitation_attempts': {},
            'successful_exploits': [],
            'findings': []
        }
        
        # Focus on exploitable vulnerabilities
        exploit_tasks = []
        
        # SQL injection exploitation
        if options.get('test_sqli', True):
            exploit_tasks.append(self._aggressive_sqli_test(target, options))
        
        # XSS exploitation
        if options.get('test_xss', True):
            exploit_tasks.append(self._xss_exploitation_test(target, options))
        
        # SSRF testing
        if options.get('test_ssrf', True):
            exploit_tasks.append(self._ssrf_exploitation_test(target, options))
        
        # Command injection
        if options.get('test_rce', True):
            exploit_tasks.append(self._command_injection_test(target, options))
        
        # Execute exploitation tasks
        exploit_results = await asyncio.gather(*exploit_tasks, return_exceptions=True)
        
        # Process exploitation results
        for i, result in enumerate(exploit_results):
            method_name = f"exploit_method_{i}"
            
            if isinstance(result, Exception):
                results['exploitation_attempts'][method_name] = {
                    'status': 'failed',
                    'error': str(result)
                }
            else:
                results['exploitation_attempts'][method_name] = result
                
                if result.get('exploitable', False):
                    results['successful_exploits'].append({
                        'method': method_name,
                        'vulnerability': result.get('vulnerability_type'),
                        'payload': result.get('successful_payload'),
                        'impact': result.get('impact')
                    })
                
                if 'findings' in result:
                    results['findings'].extend(result['findings'])
        
        return results
    
    async def _nuclei_scan(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive Nuclei vulnerability scan"""
        
        try:
            if not self.scan_engine.is_tool_available('nuclei'):
                raise RuntimeError("Nuclei MCP tool not available")
            
            # Get scan parameters
            severity = options.get('severity', ['critical', 'high', 'medium', 'low', 'info'])
            templates = options.get('templates', [])
            tags = options.get('tags', [])
            
            scan_params = {
                'target': target,
                'severity': severity,
                'concurrency': options.get('concurrency', 25),
                'timeout': options.get('timeout', 30)
            }
            
            if templates:
                scan_params['templates'] = templates
            if tags:
                scan_params['tags'] = tags
            
            result = await self.scan_engine.run_tool('nuclei', 'scan', scan_params)
            
            findings = []
            if result.get('status') == 'success':
                for finding in result.get('results', []):
                    formatted_finding = self._format_nuclei_finding(finding)
                    findings.append(formatted_finding)
            
            return {
                'method': 'nuclei',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings),
                'scan_parameters': scan_params
            }
            
        except Exception as e:
            logger.error(f"Nuclei scan failed: {e}")
            return {
                'method': 'nuclei',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _nuclei_basic_scan(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Basic Nuclei scan with essential templates"""
        
        try:
            if not self.scan_engine.is_tool_available('nuclei'):
                # Fallback to direct nuclei execution
                return await self._direct_nuclei_scan(target, {'severity': ['critical', 'high']})
            
            result = await self.scan_engine.run_tool(
                'nuclei',
                'scan',
                {
                    'target': target,
                    'severity': ['critical', 'high'],
                    'tags': ['cve', 'oast', 'rce', 'sqli'],
                    'concurrency': 15
                }
            )
            
            findings = []
            if result.get('status') == 'success':
                for finding in result.get('results', []):
                    formatted_finding = self._format_nuclei_finding(finding)
                    findings.append(formatted_finding)
            
            return {
                'method': 'nuclei_basic',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"Basic Nuclei scan failed: {e}")
            return {
                'method': 'nuclei_basic',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _direct_nuclei_scan(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Direct Nuclei execution fallback"""
        
        try:
            cmd = [
                'nuclei',
                '-target', target,
                '-json',
                '-severity', ','.join(options.get('severity', ['critical', 'high'])),
                '-timeout', '30'
            ]
            
            # Add templates path if configured
            if config.nuclei_templates_path and Path(config.nuclei_templates_path).exists():
                cmd.extend(['-templates', config.nuclei_templates_path])
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=300)
            
            findings = []
            for line in stdout.decode().strip().split('\n'):
                if line.strip():
                    try:
                        finding_data = json.loads(line)
                        formatted_finding = self._format_nuclei_finding(finding_data)
                        findings.append(formatted_finding)
                    except json.JSONDecodeError:
                        continue
            
            return {
                'method': 'nuclei_direct',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"Direct Nuclei scan failed: {e}")
            return {
                'method': 'nuclei_direct',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _sqlmap_scan(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """SQL injection testing using SQLMap"""
        
        try:
            if not self.scan_engine.is_tool_available('sqlmap'):
                return await self._basic_sqli_test(target, options)
            
            result = await self.scan_engine.run_tool(
                'sqlmap',
                'scan',
                {
                    'target': target,
                    'level': options.get('sqlmap_level', 3),
                    'risk': options.get('sqlmap_risk', 2),
                    'batch': True
                }
            )
            
            findings = []
            if result.get('status') == 'success':
                for sqli_finding in result.get('results', []):
                    if sqli_finding.get('vulnerable', False):
                        finding = {
                            'title': 'SQL Injection Vulnerability',
                            'severity': 'high',
                            'description': f"SQL injection found in parameter: {sqli_finding.get('parameter', 'unknown')}",
                            'url': sqli_finding.get('url', target),
                            'vulnerability_type': 'sqli',
                            'parameter': sqli_finding.get('parameter'),
                            'injection_type': sqli_finding.get('injection_type'),
                            'payload': sqli_finding.get('payload'),
                            'evidence': sqli_finding.get('evidence')
                        }
                        findings.append(finding)
            
            return {
                'method': 'sqlmap',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"SQLMap scan failed: {e}")
            return {
                'method': 'sqlmap',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _basic_sqli_test(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Basic SQL injection testing"""
        
        try:
            findings = []
            
            # Basic SQL injection payloads
            payloads = [
                "' OR '1'='1",
                "\" OR \"1\"=\"1",
                "' OR 1=1--",
                "\" OR 1=1--",
                "' UNION SELECT 1,2,3--",
                "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--"
            ]
            
            async with httpx.AsyncClient(timeout=10.0) as client:
                for payload in payloads:
                    try:
                        # Test GET parameter
                        test_url = f"{target}?id={payload}"
                        response = await client.get(test_url)
                        
                        if self._detect_sql_error(response.text):
                            finding = {
                                'title': 'Potential SQL Injection',
                                'severity': 'medium',
                                'description': 'SQL error detected in response',
                                'url': test_url,
                                'vulnerability_type': 'sqli',
                                'payload': payload,
                                'evidence': 'SQL error in response'
                            }
                            findings.append(finding)
                            break
                            
                    except Exception:
                        continue
            
            return {
                'method': 'basic_sqli',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"Basic SQL injection test failed: {e}")
            return {
                'method': 'basic_sqli',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _security_headers_analysis(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze security headers"""
        
        try:
            findings = []
            
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(target)
                headers = response.headers
                
                # Check for missing security headers
                security_headers = {
                    'X-Frame-Options': 'missing_x_frame_options',
                    'X-Content-Type-Options': 'missing_x_content_type_options',
                    'X-XSS-Protection': 'missing_x_xss_protection',
                    'Strict-Transport-Security': 'missing_hsts',
                    'Content-Security-Policy': 'missing_csp',
                    'Referrer-Policy': 'missing_referrer_policy'
                }
                
                for header, finding_type in security_headers.items():
                    if header not in headers:
                        finding = {
                            'title': f'Missing {header} Header',
                            'severity': 'medium' if header in ['X-Frame-Options', 'Content-Security-Policy'] else 'low',
                            'description': f'The {header} security header is missing',
                            'url': target,
                            'vulnerability_type': 'missing_security_header',
                            'header_name': header,
                            'recommendation': f'Add {header} header to improve security'
                        }
                        findings.append(finding)
                
                # Check for insecure header values
                if 'X-Frame-Options' in headers and headers['X-Frame-Options'].upper() == 'ALLOWALL':
                    finding = {
                        'title': 'Insecure X-Frame-Options Header',
                        'severity': 'medium',
                        'description': 'X-Frame-Options is set to ALLOWALL, allowing clickjacking',
                        'url': target,
                        'vulnerability_type': 'insecure_header_value',
                        'header_name': 'X-Frame-Options',
                        'header_value': headers['X-Frame-Options']
                    }
                    findings.append(finding)
            
            return {
                'method': 'security_headers',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"Security headers analysis failed: {e}")
            return {
                'method': 'security_headers',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _ssl_analysis(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """SSL/TLS configuration analysis"""
        
        try:
            if not self.scan_engine.is_tool_available('sslscan'):
                return await self._basic_ssl_check(target, options)
            
            result = await self.scan_engine.run_tool(
                'sslscan',
                'scan',
                {'target': target}
            )
            
            findings = []
            if result.get('status') == 'success':
                ssl_data = result.get('results', {})
                
                # Check for weak ciphers
                weak_ciphers = ssl_data.get('weak_ciphers', [])
                if weak_ciphers:
                    finding = {
                        'title': 'Weak SSL/TLS Ciphers',
                        'severity': 'medium',
                        'description': f'Weak ciphers detected: {", ".join(weak_ciphers)}',
                        'url': target,
                        'vulnerability_type': 'weak_ssl_cipher',
                        'weak_ciphers': weak_ciphers
                    }
                    findings.append(finding)
                
                # Check SSL version
                ssl_version = ssl_data.get('version')
                if ssl_version and ssl_version in ['SSLv2', 'SSLv3', 'TLSv1.0']:
                    finding = {
                        'title': 'Outdated SSL/TLS Version',
                        'severity': 'high' if ssl_version in ['SSLv2', 'SSLv3'] else 'medium',
                        'description': f'Outdated SSL/TLS version: {ssl_version}',
                        'url': target,
                        'vulnerability_type': 'outdated_ssl_version',
                        'ssl_version': ssl_version
                    }
                    findings.append(finding)
            
            return {
                'method': 'ssl_analysis',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"SSL analysis failed: {e}")
            return {
                'method': 'ssl_analysis',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _basic_ssl_check(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Basic SSL check fallback"""
        
        try:
            import ssl
            import socket
            from urllib.parse import urlparse
            
            parsed = urlparse(target)
            hostname = parsed.hostname or target
            port = parsed.port or 443
            
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    version = ssock.version()
            
            findings = []
            
            # Check SSL version
            if version in ['SSLv2', 'SSLv3', 'TLSv1']:
                finding = {
                    'title': f'Outdated SSL/TLS Version: {version}',
                    'severity': 'high' if version in ['SSLv2', 'SSLv3'] else 'medium',
                    'description': f'Server supports outdated SSL/TLS version: {version}',
                    'url': target,
                    'vulnerability_type': 'outdated_ssl_version',
                    'ssl_version': version
                }
                findings.append(finding)
            
            return {
                'method': 'basic_ssl_check',
                'status': 'success',
                'findings': findings,
                'total_findings': len(findings)
            }
            
        except Exception as e:
            logger.error(f"Basic SSL check failed: {e}")
            return {
                'method': 'basic_ssl_check',
                'status': 'failed',
                'error': str(e),
                'findings': []
            }
    
    async def _custom_vulnerability_checks(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Custom vulnerability checks"""
        
        findings = []
        
        # Directory traversal test
        traversal_finding = await self._test_directory_traversal(target)
        if traversal_finding:
            findings.append(traversal_finding)
        
        # Open redirect test
        redirect_finding = await self._test_open_redirect(target)
        if redirect_finding:
            findings.append(redirect_finding)
        
        # CORS misconfiguration test
        cors_finding = await self._test_cors_misconfiguration(target)
        if cors_finding:
            findings.append(cors_finding)
        
        return {
            'method': 'custom_checks',
            'status': 'success',
            'findings': findings,
            'total_findings': len(findings)
        }
    
    async def _common_vulnerability_checks(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Common vulnerability checks for basic scan"""
        
        findings = []
        
        # XSS test
        xss_finding = await self._basic_xss_test(target)
        if xss_finding:
            findings.append(xss_finding)
        
        # Directory traversal
        traversal_finding = await self._test_directory_traversal(target)
        if traversal_finding:
            findings.append(traversal_finding)
        
        return {
            'method': 'common_checks',
            'status': 'success',
            'findings': findings,
            'total_findings': len(findings)
        }
    
    async def _test_directory_traversal(self, target: str) -> Dict[str, Any]:
        """Test for directory traversal vulnerabilities"""
        
        try:
            payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '....//....//....//etc/passwd'
            ]
            
            async with httpx.AsyncClient(timeout=10.0) as client:
                for payload in payloads:
                    test_url = f"{target}?file={payload}"
                    try:
                        response = await client.get(test_url)
                        
                        if ('root:' in response.text.lower() or 
                            'localhost' in response.text.lower()):
                            return {
                                'title': 'Directory Traversal Vulnerability',
                                'severity': 'high',
                                'description': 'Local file inclusion detected',
                                'url': test_url,
                                'vulnerability_type': 'directory_traversal',
                                'payload': payload,
                                'evidence': 'System file contents in response'
                            }
                    except Exception:
                        continue
            
            return None
            
        except Exception as e:
            logger.error(f"Directory traversal test failed: {e}")
            return None
    
    async def _test_open_redirect(self, target: str) -> Dict[str, Any]:
        """Test for open redirect vulnerabilities"""
        
        try:
            test_domain = "evil.com"
            params = ['url', 'redirect', 'next', 'return', 'goto', 'link']
            
            async with httpx.AsyncClient(timeout=10.0, follow_redirects=False) as client:
                for param in params:
                    test_url = f"{target}?{param}=http://{test_domain}"
                    try:
                        response = await client.get(test_url)
                        
                        if (response.status_code in [301, 302, 303, 307, 308] and
                            'location' in response.headers and
                            test_domain in response.headers['location']):
                            return {
                                'title': 'Open Redirect Vulnerability',
                                'severity': 'medium',
                                'description': f'Open redirect found in parameter: {param}',
                                'url': test_url,
                                'vulnerability_type': 'open_redirect',
                                'parameter': param,
                                'redirect_location': response.headers['location']
                            }
                    except Exception:
                        continue
            
            return None
            
        except Exception as e:
            logger.error(f"Open redirect test failed: {e}")
            return None
    
    async def _test_cors_misconfiguration(self, target: str) -> Dict[str, Any]:
        """Test for CORS misconfiguration"""
        
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                headers = {'Origin': 'https://evil.com'}
                response = await client.options(target, headers=headers)
                
                cors_header = response.headers.get('Access-Control-Allow-Origin', '')
                
                if cors_header == '*':
                    return {
                        'title': 'CORS Misconfiguration - Wildcard Origin',
                        'severity': 'medium',
                        'description': 'CORS policy allows any origin (*)',
                        'url': target,
                        'vulnerability_type': 'cors_misconfiguration',
                        'cors_header': cors_header
                    }
                elif 'evil.com' in cors_header:
                    return {
                        'title': 'CORS Misconfiguration - Reflected Origin',
                        'severity': 'high',
                        'description': 'CORS policy reflects arbitrary origins',
                        'url': target,
                        'vulnerability_type': 'cors_misconfiguration',
                        'cors_header': cors_header
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"CORS test failed: {e}")
            return None
    
    async def _basic_xss_test(self, target: str) -> Dict[str, Any]:
        """Basic XSS testing"""
        
        try:
            payload = "<script>alert('XSS')</script>"
            
            async with httpx.AsyncClient(timeout=10.0) as client:
                # Test GET parameter
                test_url = f"{target}?q={payload}"
                response = await client.get(test_url)
                
                if payload in response.text:
                    return {
                        'title': 'Reflected XSS Vulnerability',
                        'severity': 'medium',
                        'description': 'Reflected XSS found in GET parameter',
                        'url': test_url,
                        'vulnerability_type': 'xss',
                        'payload': payload,
                        'evidence': 'Payload reflected in response'
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"XSS test failed: {e}")
            return None
    
    async def _aggressive_sqli_test(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Aggressive SQL injection testing for exploitation scan"""
        # Implementation for more aggressive SQL injection testing
        return await self._basic_sqli_test(target, options)
    
    async def _xss_exploitation_test(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """XSS exploitation testing"""
        # Implementation for XSS exploitation
        return await self._basic_xss_test(target)
    
    async def _ssrf_exploitation_test(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """SSRF exploitation testing"""
        # Implementation for SSRF testing
        return {'method': 'ssrf_test', 'status': 'not_implemented', 'findings': []}
    
    async def _command_injection_test(self, target: str, options: Dict[str, Any]) -> Dict[str, Any]:
        """Command injection testing"""
        # Implementation for command injection testing
        return {'method': 'command_injection', 'status': 'not_implemented', 'findings': []}
    
    def _format_nuclei_finding(self, finding: Dict[str, Any]) -> Dict[str, Any]:
        """Format Nuclei finding to standard format"""
        
        return {
            'title': finding.get('template-id', 'Unknown'),
            'severity': finding.get('info', {}).get('severity', 'info'),
            'description': finding.get('info', {}).get('name', ''),
            'url': finding.get('matched-at', ''),
            'vulnerability_type': finding.get('type', 'nuclei'),
            'template_id': finding.get('template-id'),
            'matcher_name': finding.get('matcher-name'),
            'extracted_results': finding.get('extracted-results', []),
            'curl_command': finding.get('curl-command', ''),
            'timestamp': finding.get('timestamp')
        }
    
    def _detect_sql_error(self, response_text: str) -> bool:
        """Detect SQL errors in response"""
        
        sql_errors = [
            'SQL syntax',
            'mysql_fetch',
            'ORA-01756',
            'Microsoft OLE DB Provider for ODBC Drivers',
            'PostgreSQL query failed',
            'Warning: pg_',
            'valid MySQL result',
            'MySqlClient.',
            'SQLite/JDBCDriver',
            'SQLite.Exception',
            'System.Data.SQLite.SQLiteException',
            'Warning: sqlite_',
            'OdbcException',
            'Microsoft Access Driver',
            'JET Database Engine',
            'Access Database Engine'
        ]
        
        response_lower = response_text.lower()
        return any(error.lower() in response_lower for error in sql_errors)
    
    def _deduplicate_findings(self, findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Remove duplicate findings"""
        
        seen = set()
        unique_findings = []
        
        for finding in findings:
            # Create a simple hash for deduplication
            key = (
                finding.get('title', ''),
                finding.get('url', ''),
                finding.get('vulnerability_type', '')
            )
            
            if key not in seen:
                seen.add(key)
                unique_findings.append(finding)
        
        return unique_findings
    
    def _calculate_summary(self, findings: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate summary statistics for findings"""
        
        summary = {
            'total_findings': len(findings),
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0
        }
        
        for finding in findings:
            severity = finding.get('severity', 'info').lower()
            if severity in summary:
                summary[severity] += 1
        
        return summary